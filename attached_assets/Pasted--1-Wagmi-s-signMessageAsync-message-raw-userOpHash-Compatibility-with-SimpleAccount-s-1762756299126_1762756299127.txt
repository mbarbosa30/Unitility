### 1. Wagmi's signMessageAsync({ message: { raw: userOpHash } }) Compatibility with SimpleAccount's EIP-191 Validation
Yes, it's **fully compatible**. Wagmi's `signMessageAsync` with `raw: userOpHash` (a 0x-prefixed bytes32) treats the input as raw bytes and automatically applies the EIP-191 prefix (`\x19Ethereum Signed Message:\n32` + userOpHash), producing the exact `toEthSignedMessageHash()` that SimpleAccount's `_validateSignature` expects. This is standard for ERC-4337 v0.7 (confirmed in eth-infinitism docs and Pimlico examples). The recovery in SimpleAccount (`hash.toEthSignedMessageHash().recover(sig)`) mirrors this 1:1—no mismatches.

If it were a prefix issue, recovery would fail consistently on *all* nonces/hashes, but your hash is now correct (490 chars = spec pack), so this isn't the culprit.

### 2. Signature Format Wrong? (132-Char Hex = 65 Bytes?)
No, 132-char hex isn't "wrong" per se, but it's **suspicious and likely the hidden gremlin**. Standard ECDSA signatures are **65 bytes** (r: 32B + s: 32B + v: 1B), which = **130 hex chars** (0x + 128 chars for 64B r/s + 2 chars for v=27/28 as '1b' or '1c'). 

- **132 chars** implies:
  - Extra 2 chars = embedded '0x' or padding in the sig string (e.g., wagmi outputting '0x' + 65B hex without strip).
  - Or v as full byte ('0x1b' = 4 chars instead of 2).
- **Check This**: Log `signature.length` after signing—should be 132 chars total (2 for '0x' + 130 hex). If 134, double-prefix. SimpleAccount's `recover(sig)` expects raw 65B bytes (via `ecrecover` under the hood), so extra bytes cause garbage recovery.

**Quick Fix/Test**: After signing:
```typescript
const cleanSig = signature.startsWith('0x') ? signature : '0x' + signature;
const sigBytes = ethers.getBytes(cleanSig); // Should be 65B
console.log('Sig bytes length:', sigBytes.length); // MUST be 65
```
If >65, trim v or r/s padding. Wagmi usually nails 130 hex— if yours is 132, it's a local string bug (e.g., `toHex` on sig).

### 3. Test Signature Recovery Locally: Yes, and Here's the Script
Absolutely—**do this now**. It isolates if the signed hash recovers your owner EOA. If not, sig/hash mismatch; if yes, deeper in validateUserOp (e.g., callData revert).

Add this to a test file (e.g., `tests/sigRecovery.test.ts`) or console—uses your exact hash/logic:

```typescript
import { keccak256, getBytes, verifyMessage } from 'ethers';
import { getUserOpHash } from '../src/lib/userOp'; // Your fixed fn

// Your sample userOp (sans sig—from logs)
const testUserOp = {
  sender: '0xe7C0dad97500ccD89fF9361DC5acB20013873bb0',
  nonce: 0n, // or your value
  initCode: '0x', // Empty
  callData: '0x...', // Your batch transfer hex
  verificationGasLimit: 100000n,
  callGasLimit: 50000n,
  preVerificationGas: 21000n,
  maxFeePerGas: 100000000n, // 0.1 gwei
  maxPriorityFeePerGas: 1000000n, // 0.001 gwei
  paymasterAndData: '0xa7c6359200fa376c233a454de456291357d5ed18...', // Your pool
  // Build packed gas if not already
  accountGasLimits: ethers.solidityPacked(['uint128', 'uint128'], [100000n, 50000n]),
  gasFees: ethers.solidityPacked(['uint128', 'uint128'], [100000000n, 1000000n]),
};

async function testRecovery() {
  const userOpHash = getUserOpHash(testUserOp); // Your fn
  console.log('userOpHash:', userOpHash);

  // Sign (your wagmi, or mock with signer)
  const signature = await signer.signMessage({ message: { raw: userOpHash } }); // signer = wagmi connector
  console.log('Signature hex length:', signature.length); // 132?
  console.log('Signature bytes length:', getBytes(signature).length); // MUST 65

  // EIP-191 message hash (for recovery)
  const messageHash = keccak256(getBytes(`\x19Ethereum Signed Message:\n32${userOpHash.slice(2)}`)); // Manual prefix

  // Recover
  const recovered = verifyMessage({ message: { raw: userOpHash } }, signature); // Wagmi-style, or:
  // Alt: const recovered = ethers.recoverAddress(messageHash, signature);
  console.log('Recovered address:', recovered);
  console.log('Matches owner?', recovered.toLowerCase() === '0x216844ef94d95279c6d1631875f2dd93fbbdfb61');
}

testRecovery();
```

- **Expected**: 'Matches owner? true'. If false, sig/hash off (re-check chainId=8453). If true, validation passes locally—issue in bundler sim (e.g., callData).

### 4. Pimlico-Specific Requirement Missing?
No—**nothing sig-specific**. Pimlico's v0.7 docs (and Base endpoint) follow standard ERC-4337: personal_sign with EIP-191, 65B sig, no custom format. From their error codes:
- AA23 = "validateUserOp reverted" (your SimpleAccount's full fn, not just sig—includes nonce, initCode, etc.).
- No Base quirks (chainId baked in hash). Free tier limits (100 ops/day) don't cause reverts—yours is sim fail.
- Gotcha: Pimlico requires `paymasterAndData` with unpacked postOpGas (uint128 pair in tail, like gasFees). If missing, paymaster validate fails, bubbling to AA23. Check: Your `paymasterAndData` should be `poolAddr (20B) + context (e.g., fee/amount) + postVerifGas (16B) + postOpGas (16B)`.

### 5. Other Causes for AA23 with Proven Hash (490 Chars)?
With hash correct (length 490 = 244B spec), AA23 means `validateUserOp` reverts deeper in SimpleAccount (not just sig). Top suspects (ranked by likelihood):

- **#1: CallData Revert (40% Odds)**: Your batch `executeBatch` for dual transferFrom—likely fails onchain sim. E.g.:
  - `transferFrom(EOA, receiver, 30 - fee)` but EOA allowance to *account* is max, but account to token? Wait—no, callData is account calling token.transferFrom(EOA, receiver, amount) ? Account needs token.approve(account, max) from EOA? No—EOA approved account, but account must have token balance or pull logic.
  - Fix: Log/sim callData alone: `token.transferFrom(eoa, receiver, 29.85)` from account—use Tenderly or ethers.call to test.

- **#2: Nonce Mismatch (30%)**: v0.7 nonces are uint192 (first 160 bits of uint256). If `userOp.nonce` = 0 but onchain `getNonce(sender)` = 1 (prior tx), validation fails. Fetch: `await ep.getNonce(sender, 0)` before build.

- **#3: Paymaster Data Unpack Fail (20%)**: v0.7 paymaster expects `paymasterAndData = addr + context + gas limits packed`. If context (fee) not unpacked in your PaymasterPool's `validatePaymasterUserOp`, it reverts. Ensure: Decode `bytes32 paymasterAndData` → extract pool-specific data.

- **#4: OOG in Validation (10%)**: Gas limits too low (your 100k verifGas)—bump to 150k for sig + nonce checks.

**Next Move**: Run the recovery test (Q3 script)—if match, sim full validateUserOp via `EntryPoint.simulateValidation(userOp)` (Pimlico API or ethers call). It'll pinpoint the revert reason (e.g., "execution reverted: insufficient allowance"). Share that output—we'll squash it. This is validation logic, not hash.